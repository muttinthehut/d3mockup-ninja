{"ts":1365014283273,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"/>\r\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\"/>\r\n    <script type=\"text/javascript\" src=\"d3/d3.js\"></script>\r\n    <script type=\"text/javascript\" src=\"d3/d3.layout.js\"></script>\r\n    <style type=\"text/css\">\r\n\r\n\r\n.node circle {\r\n  cursor: pointer;\r\n  fill: #fff;\r\n  stroke: steelblue;\r\n  stroke-width: 1.5px;\r\n}\r\n\r\n.node text {\r\n  font-size: 11px;\r\n}\r\n\r\npath.link {\r\n  fill: none;\r\n  stroke: #ccc;\r\n  stroke-width: 1.5px;\r\n}\r\n\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"body\">\r\n      <div id=\"footer\">\r\n        d3.layout.tree\r\n        <div class=\"hint\">click or option-click to expand or collapse</div>\r\n      </div>\r\n    </div>\r\n    <script type=\"text/javascript\">\r\n\r\nvar m = [20, 120, 20, 120],\r\n    w = 1280 - m[1] - m[3],\r\n    h = 800 - m[0] - m[2],\r\n    i = 0,\r\n    root;\r\n\r\nvar tree = d3.layout.tree()\r\n    .size([h, w]);\r\n\r\nvar diagonal = d3.svg.diagonal()\r\n    .projection(function(d) { return [d.y, d.x]; });\r\n\r\nvar vis = d3.select(\"#body\").append(\"svg:svg\")\r\n    .attr(\"width\", w + m[1] + m[3])\r\n    .attr(\"height\", h + m[0] + m[2])\r\n  .append(\"svg:g\")\r\n    .attr(\"transform\", \"translate(\" + m[3] + \",\" + m[0] + \")\");\r\n\r\nd3.json(\"flare.json\", function(json) {\r\n  root = json;\r\n  root.x0 = h / 2;\r\n  root.y0 = 0;\r\n\r\n  function toggleAll(d) {\r\n    if (d.children) {\r\n      d.children.forEach(toggleAll);\r\n      toggle(d);\r\n    }\r\n  }\r\n\r\n  // Initialize the display to show a few nodes.\r\n  root.children.forEach(toggleAll);\r\n  toggle(root.children[1]);\r\n  toggle(root.children[1].children[2]);\r\n  toggle(root.children[9]);\r\n  toggle(root.children[9].children[0]);\r\n\r\n  update(root);\r\n});\r\n\r\nfunction update(source) {\r\n  var duration = d3.event && d3.event.altKey ? 5000 : 500;\r\n\r\n  // Compute the new tree layout.\r\n  var nodes = tree.nodes(root).reverse();\r\n\r\n  // Normalize for fixed-depth.\r\n  nodes.forEach(function(d) { d.y = d.depth * 180; });\r\n\r\n  // Update the nodes…\r\n  var node = vis.selectAll(\"g.node\")\r\n      .data(nodes, function(d) { return d.id || (d.id = ++i); });\r\n\r\n  // Enter any new nodes at the parent's previous position.\r\n  var nodeEnter = node.enter().append(\"svg:g\")\r\n      .attr(\"class\", \"node\")\r\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y0 + \",\" + source.x0 + \")\"; })\r\n      .on(\"click\", function(d) { toggle(d); update(d); });\r\n\r\n  nodeEnter.append(\"svg:circle\")\r\n      .attr(\"r\", 1e-6)\r\n      .style(\"fill\", function(d) { return d._children ? \"lightsteelblue\" : \"#fff\"; });\r\n\r\n  nodeEnter.append(\"svg:text\")\r\n      .attr(\"x\", function(d) { return d.children || d._children ? -10 : 10; })\r\n      .attr(\"dy\", \".35em\")\r\n      .attr(\"text-anchor\", function(d) { return d.children || d._children ? \"end\" : \"start\"; })\r\n      .text(function(d) { return d.name; })\r\n      .style(\"fill-opacity\", 1e-6);\r\n\r\n  // Transition nodes to their new position.\r\n  var nodeUpdate = node.transition()\r\n      .duration(duration)\r\n      .attr(\"transform\", function(d) { return \"translate(\" + d.y + \",\" + d.x + \")\"; });\r\n\r\n  nodeUpdate.select(\"circle\")\r\n      .attr(\"r\", 4.5)\r\n      .style(\"fill\", function(d) { return d._children ? \"lightsteelblue\" : \"#fff\"; });\r\n\r\n  nodeUpdate.select(\"text\")\r\n      .style(\"fill-opacity\", 1);\r\n\r\n  // Transition exiting nodes to the parent's new position.\r\n  var nodeExit = node.exit().transition()\r\n      .duration(duration)\r\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y + \",\" + source.x + \")\"; })\r\n      .remove();\r\n\r\n  nodeExit.select(\"circle\")\r\n      .attr(\"r\", 1e-6);\r\n\r\n  nodeExit.select(\"text\")\r\n      .style(\"fill-opacity\", 1e-6);\r\n\r\n  // Update the links…\r\n  var link = vis.selectAll(\"path.link\")\r\n      .data(tree.links(nodes), function(d) { return d.target.id; });\r\n\r\n  // Enter any new links at the parent's previous position.\r\n  link.enter().insert(\"svg:path\", \"g\")\r\n      .attr(\"class\", \"link\")\r\n      .attr(\"d\", function(d) {\r\n        var o = {x: source.x0, y: source.y0};\r\n        return diagonal({source: o, target: o});\r\n      })\r\n    .transition()\r\n      .duration(duration)\r\n      .attr(\"d\", diagonal);\r\n\r\n  // Transition links to their new position.\r\n  link.transition()\r\n      .duration(duration)\r\n      .attr(\"d\", diagonal);\r\n\r\n  // Transition exiting nodes to the parent's new position.\r\n  link.exit().transition()\r\n      .duration(duration)\r\n      .attr(\"d\", function(d) {\r\n        var o = {x: source.x, y: source.y};\r\n        return diagonal({source: o, target: o});\r\n      })\r\n      .remove();\r\n\r\n  // Stash the old positions for transition.\r\n  nodes.forEach(function(d) {\r\n    d.x0 = d.x;\r\n    d.y0 = d.y;\r\n  });\r\n}\r\n\r\n// Toggle children.\r\nfunction toggle(d) {\r\n  if (d.children) {\r\n    d._children = d.children;\r\n    d.children = null;\r\n  } else {\r\n    d.children = d._children;\r\n    d._children = null;\r\n  }\r\n}\r\n\r\n    </script>\r\n  </body>\r\n</html>\r\n"]],"start1":0,"start2":0,"length1":0,"length2":4906}]],"length":4906}
{"contributors":[],"silentsave":false,"ts":1365014693447,"patch":[[{"diffs":[[-1,"\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"/>\r\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\"/>\r\n    <script type=\"text/javascript\" src=\"d3/d3.js\"></script>\r\n    <script type=\"text/javascript\" src=\"d3/d3.layout.js\"></script>\r\n    <style type=\"text/css\">\r\n\r\n\r\n.node circle {\r\n  cursor: pointer;\r\n  fill: #fff;\r\n  stroke: steelblue;\r\n  stroke-width: 1.5px;\r\n}\r\n\r\n.node text {\r\n  font-size: 11px;\r\n}\r\n\r\npath.link {\r\n  fill: none;\r\n  stroke: #ccc;\r\n  stroke-width: 1.5px;\r\n}\r\n\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"body\">\r\n      <div id=\"footer\">\r\n        d3.layout.tree\r\n        <div class=\"hint\">click or option-click to expand or collapse</div>\r\n      </div>\r\n    </div>\r\n    <script type=\"text/javascript\">\r\n\r\nvar m = [20, 120, 20, 120],\r\n    w = 1280 - m[1] - m[3],\r\n    h = 800 - m[0] - m[2],\r\n    i = 0,\r\n    root;\r\n\r\nvar tree = d3.layout.tree()\r\n    .size([h, w]);\r\n\r\nvar diagonal = d3.svg.diagonal()\r\n    .projection(function(d) { return [d.y, d.x]; });\r\n\r\nvar vis = d3.select(\"#body\").append(\"svg:svg\")\r\n    .attr(\"width\", w + m[1] + m[3])\r\n    .attr(\"height\", h + m[0] + m[2])\r\n  .append(\"svg:g\")\r\n    .attr(\"transform\", \"translate(\" + m[3] + \",\" + m[0] + \")\");\r\n\r\nd3.json(\"flare.json\", function(json) {\r\n  root = json;\r\n  root.x0 = h / 2;\r\n  root.y0 = 0;\r\n\r\n  function toggleAll(d) {\r\n    if (d.children) {\r\n      d.children.forEach(toggleAll);\r\n      toggle(d);\r\n    }\r\n  }\r\n\r\n  // Initialize the display to show a few nodes.\r\n  root.children.forEach(toggleAll);\r\n  toggle(root.children[1]);\r\n  toggle(root.children[1].children[2]);\r\n  toggle(root.children[9]);\r\n  toggle(root.children[9].children[0]);\r\n\r\n  update(root);\r\n});\r\n\r\nfunction update(source) {\r\n  var duration = d3.event && d3.event.altKey ? 5000 : 500;\r\n\r\n  // Compute the new tree layout.\r\n  var nodes = tree.nodes(root).reverse();\r\n\r\n  // Normalize for fixed-depth.\r\n  nodes.forEach(function(d) { d.y = d.depth * 180; });\r\n\r\n  // Update the nodes…\r\n  var node = vis.selectAll(\"g.node\")\r\n      .data(nodes, function(d) { return d.id || (d.id = ++i); });\r\n\r\n  // Enter any new nodes at the parent's previous position.\r\n  var nodeEnter = node.enter().append(\"svg:g\")\r\n      .attr(\"class\", \"node\")\r\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y0 + \",\" + source.x0 + \")\"; })\r\n      .on(\"click\", function(d) { toggle(d); update(d); });\r\n\r\n  nodeEnter.append(\"svg:circle\")\r\n      .attr(\"r\", 1e-6)\r\n      .style(\"fill\", function(d) { return d._children ? \"lightsteelblue\" : \"#fff\"; });\r\n\r\n  nodeEnter.append(\"svg:text\")\r\n      .attr(\"x\", function(d) { return d.children || d._children ? -10 : 10; })\r\n      .attr(\"dy\", \".35em\")\r\n      .attr(\"text-anchor\", function(d) { return d.children || d._children ? \"end\" : \"start\"; })\r\n      .text(function(d) { return d.name; })\r\n      .style(\"fill-opacity\", 1e-6);\r\n\r\n  // Transition nodes to their new position.\r\n  var nodeUpdate = node.transition()\r\n      .duration(duration)\r\n      .attr(\"transform\", function(d) { return \"translate(\" + d.y + \",\" + d.x + \")\"; });\r\n\r\n  nodeUpdate.select(\"circle\")\r\n      .attr(\"r\", 4.5)\r\n      .style(\"fill\", function(d) { return d._children ? \"lightsteelblue\" : \"#fff\"; });\r\n\r\n  nodeUpdate.select(\"text\")\r\n      .style(\"fill-opacity\", 1);\r\n\r\n  // Transition exiting nodes to the parent's new position.\r\n  var nodeExit = node.exit().transition()\r\n      .duration(duration)\r\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y + \",\" + source.x + \")\"; })\r\n      .remove();\r\n\r\n  nodeExit.select(\"circle\")\r\n      .attr(\"r\", 1e-6);\r\n\r\n  nodeExit.select(\"text\")\r\n      .style(\"fill-opacity\", 1e-6);\r\n\r\n  // Update the links…\r\n  var link = vis.selectAll(\"path.link\")\r\n      .data(tree.links(nodes), function(d) { return d.target.id; });\r\n\r\n  // Enter any new links at the parent's previous position.\r\n  link.enter().insert(\"svg:path\", \"g\")\r\n      .attr(\"class\", \"link\")\r\n      .attr(\"d\", function(d) {\r\n        var o = {x: source.x0, y: source.y0};\r\n        return diagonal({source: o, target: o});\r\n      })\r\n    .transition()\r\n      .duration(duration)\r\n      .attr(\"d\", diagonal);\r\n\r\n  // Transition links to their new position.\r\n  link.transition()\r\n      .duration(duration)\r\n      .attr(\"d\", diagonal);\r\n\r\n  // Transition exiting nodes to the parent's new position.\r\n  link.exit().transition()\r\n      .duration(duration)\r\n      .attr(\"d\", function(d) {\r\n        var o = {x: source.x, y: source.y};\r\n        return diagonal({source: o, target: o});\r\n      })\r\n      .remove();\r\n\r\n  // Stash the old positions for transition.\r\n  nodes.forEach(function(d) {\r\n    d.x0 = d.x;\r\n    d.y0 = d.y;\r\n  });\r\n}\r\n\r\n// Toggle children.\r\nfunction toggle(d) {\r\n  if (d.children) {\r\n    d._children = d.children;\r\n    d.children = null;\r\n  } else {\r\n    d.children = d._children;\r\n    d._children = null;\r\n  }\r\n}\r\n\r\n    </script>\r\n  </body>\r\n</html>\r\n"],[1,"(function(){d3.layout = {};\r\n// Implements hierarchical edge bundling using Holten's algorithm. For each\r\n// input link, a path is computed that travels through the tree, up the parent\r\n// hierarchy to the least common ancestor, and then back down to the destination\r\n// node. Each path is simply an array of nodes.\r\nd3.layout.bundle = function() {\r\n  return function(links) {\r\n    var paths = [],\r\n        i = -1,\r\n        n = links.length;\r\n    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\r\n    return paths;\r\n  };\r\n};\r\n\r\nfunction d3_layout_bundlePath(link) {\r\n  var start = link.source,\r\n      end = link.target,\r\n      lca = d3_layout_bundleLeastCommonAncestor(start, end),\r\n      points = [start];\r\n  while (start !== lca) {\r\n    start = start.parent;\r\n    points.push(start);\r\n  }\r\n  var k = points.length;\r\n  while (end !== lca) {\r\n    points.splice(k, 0, end);\r\n    end = end.parent;\r\n  }\r\n  return points;\r\n}\r\n\r\nfunction d3_layout_bundleAncestors(node) {\r\n  var ancestors = [],\r\n      parent = node.parent;\r\n  while (parent != null) {\r\n    ancestors.push(node);\r\n    node = parent;\r\n    parent = parent.parent;\r\n  }\r\n  ancestors.push(node);\r\n  return ancestors;\r\n}\r\n\r\nfunction d3_layout_bundleLeastCommonAncestor(a, b) {\r\n  if (a === b) return a;\r\n  var aNodes = d3_layout_bundleAncestors(a),\r\n      bNodes = d3_layout_bundleAncestors(b),\r\n      aNode = aNodes.pop(),\r\n      bNode = bNodes.pop(),\r\n      sharedNode = null;\r\n  while (aNode === bNode) {\r\n    sharedNode = aNode;\r\n    aNode = aNodes.pop();\r\n    bNode = bNodes.pop();\r\n  }\r\n  return sharedNode;\r\n}\r\nd3.layout.chord = function() {\r\n  var chord = {},\r\n      chords,\r\n      groups,\r\n      matrix,\r\n      n,\r\n      padding = 0,\r\n      sortGroups,\r\n      sortSubgroups,\r\n      sortChords;\r\n\r\n  function relayout() {\r\n    var subgroups = {},\r\n        groupSums = [],\r\n        groupIndex = d3.range(n),\r\n        subgroupIndex = [],\r\n        k,\r\n        x,\r\n        x0,\r\n        i,\r\n        j;\r\n\r\n    chords = [];\r\n    groups = [];\r\n\r\n    // Compute the sum.\r\n    k = 0, i = -1; while (++i < n) {\r\n      x = 0, j = -1; while (++j < n) {\r\n        x += matrix[i][j];\r\n      }\r\n      groupSums.push(x);\r\n      subgroupIndex.push(d3.range(n));\r\n      k += x;\r\n    }\r\n\r\n    // Sort groupsâ€¦\r\n    if (sortGroups) {\r\n      groupIndex.sort(function(a, b) {\r\n        return sortGroups(groupSums[a], groupSums[b]);\r\n      });\r\n    }\r\n\r\n    // Sort subgroupsâ€¦\r\n    if (sortSubgroups) {\r\n      subgroupIndex.forEach(function(d, i) {\r\n        d.sort(function(a, b) {\r\n          return sortSubgroups(matrix[i][a], matrix[i][b]);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Convert the sum to scaling factor for [0, 2pi].\r\n    // TODO Allow start and end angle to be specified.\r\n    // TODO Allow padding to be specified as percentage?\r\n    k = (2 * Math.PI - padding * n) / k;\r\n\r\n    // Compute the start and end angle for each group and subgroup.\r\n    x = 0, i = -1; while (++i < n) {\r\n      x0 = x, j = -1; while (++j < n) {\r\n        var di = groupIndex[i],\r\n            dj = subgroupIndex[i][j],\r\n            v = matrix[di][dj];\r\n        subgroups[di + \"-\" + dj] = {\r\n          index: di,\r\n          subindex: dj,\r\n          startAngle: x,\r\n          endAngle: x += v * k,\r\n          value: v\r\n        };\r\n      }\r\n      groups.push({\r\n        index: di,\r\n        startAngle: x0,\r\n        endAngle: x,\r\n        value: (x - x0) / k\r\n      });\r\n      x += padding;\r\n    }\r\n\r\n    // Generate chords for each (non-empty) subgroup-subgroup link.\r\n    i = -1; while (++i < n) {\r\n      j = i - 1; while (++j < n) {\r\n        var source = subgroups[i + \"-\" + j],\r\n            target = subgroups[j + \"-\" + i];\r\n        if (source.value || target.value) {\r\n          chords.push(source.value < target.value\r\n              ? {source: target, target: source}\r\n              : {source: source, target: target});\r\n        }\r\n      }\r\n    }\r\n\r\n    if (sortChords) resort();\r\n  }\r\n\r\n  function resort() {\r\n    chords.sort(function(a, b) {\r\n      return sortChords(a.target.value, b.target.value);\r\n    });\r\n  }\r\n\r\n  chord.matrix = function(x) {\r\n    if (!arguments.length) return matrix;\r\n    n = (matrix = x) && matrix.length;\r\n    chords = groups = null;\r\n    return chord;\r\n  };\r\n\r\n  chord.padding = function(x) {\r\n    if (!arguments.length) return padding;\r\n    padding = x;\r\n    chords = groups = null;\r\n    return chord;\r\n  };\r\n\r\n  chord.sortGroups = function(x) {\r\n    if (!arguments.length) return sortGroups;\r\n    sortGroups = x;\r\n    chords = groups = null;\r\n    return chord;\r\n  };\r\n\r\n  chord.sortSubgroups = function(x) {\r\n    if (!arguments.length) return sortSubgroups;\r\n    sortSubgroups = x;\r\n    chords = null;\r\n    return chord;\r\n  };\r\n\r\n  chord.sortChords = function(x) {\r\n    if (!arguments.length) return sortChords;\r\n    sortChords = x;\r\n    if (chords) resort();\r\n    return chord;\r\n  };\r\n\r\n  chord.chords = function() {\r\n    if (!chords) relayout();\r\n    return chords;\r\n  };\r\n\r\n  chord.groups = function() {\r\n    if (!groups) relayout();\r\n    return groups;\r\n  };\r\n\r\n  return chord;\r\n};\r\n// A rudimentary force layout using Gauss-Seidel.\r\nd3.layout.force = function() {\r\n  var force = {},\r\n      event = d3.dispatch(\"tick\"),\r\n      size = [1, 1],\r\n      drag,\r\n      alpha,\r\n      friction = .9,\r\n      linkDistance = d3_layout_forceLinkDistance,\r\n      linkStrength = d3_layout_forceLinkStrength,\r\n      charge = -30,\r\n      gravity = .1,\r\n      theta = .8,\r\n      interval,\r\n      nodes = [],\r\n      links = [],\r\n      distances,\r\n      strengths,\r\n      charges;\r\n\r\n  function repulse(node) {\r\n    return function(quad, x1, y1, x2, y2) {\r\n      if (quad.point !== node) {\r\n        var dx = quad.cx - node.x,\r\n            dy = quad.cy - node.y,\r\n            dn = 1 / Math.sqrt(dx * dx + dy * dy);\r\n\r\n        /* Barnes-Hut criterion. */\r\n        if ((x2 - x1) * dn < theta) {\r\n          var k = quad.charge * dn * dn;\r\n          node.px -= dx * k;\r\n          node.py -= dy * k;\r\n          return true;\r\n        }\r\n\r\n        if (quad.point && isFinite(dn)) {\r\n          var k = quad.pointCharge * dn * dn;\r\n          node.px -= dx * k;\r\n          node.py -= dy * k;\r\n        }\r\n      }\r\n      return !quad.charge;\r\n    };\r\n  }\r\n\r\n  function tick() {\r\n    var n = nodes.length,\r\n        m = links.length,\r\n        q,\r\n        i, // current index\r\n        o, // current object\r\n        s, // current source\r\n        t, // current target\r\n        l, // current distance\r\n        k, // current force\r\n        x, // x-distance\r\n        y; // y-distance\r\n\r\n    // gauss-seidel relaxation for links\r\n    for (i = 0; i < m; ++i) {\r\n      o = links[i];\r\n      s = o.source;\r\n      t = o.target;\r\n      x = t.x - s.x;\r\n      y = t.y - s.y;\r\n      if (l = (x * x + y * y)) {\r\n        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\r\n        x *= l;\r\n        y *= l;\r\n        t.x -= x * (k = s.weight / (t.weight + s.weight));\r\n        t.y -= y * k;\r\n        s.x += x * (k = 1 - k);\r\n        s.y += y * k;\r\n      }\r\n    }\r\n\r\n    // apply gravity forces\r\n    if (k = alpha * gravity) {\r\n      x = size[0] / 2;\r\n      y = size[1] / 2;\r\n      i = -1; if (k) while (++i < n) {\r\n        o = nodes[i];\r\n        o.x += (x - o.x) * k;\r\n        o.y += (y - o.y) * k;\r\n      }\r\n    }\r\n\r\n    // compute quadtree center of mass and apply charge forces\r\n    if (charge) {\r\n      d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\r\n      i = -1; while (++i < n) {\r\n        if (!(o = nodes[i]).fixed) {\r\n          q.visit(repulse(o));\r\n        }\r\n      }\r\n    }\r\n\r\n    // position verlet integration\r\n    i = -1; while (++i < n) {\r\n      o = nodes[i];\r\n      if (o.fixed) {\r\n        o.x = o.px;\r\n        o.y = o.py;\r\n      } else {\r\n        o.x -= (o.px - (o.px = o.x)) * friction;\r\n        o.y -= (o.py - (o.py = o.y)) * friction;\r\n      }\r\n    }\r\n\r\n    event.tick.dispatch({type: \"tick\", alpha: alpha});\r\n\r\n    // simulated annealing, basically\r\n    return (alpha *= .99) < .005;\r\n  }\r\n\r\n  force.on = function(type, listener) {\r\n    event[type].add(listener);\r\n    return force;\r\n  };\r\n\r\n  force.nodes = function(x) {\r\n    if (!arguments.length) return nodes;\r\n    nodes = x;\r\n    return force;\r\n  };\r\n\r\n  force.links = function(x) {\r\n    if (!arguments.length) return links;\r\n    links = x;\r\n    return force;\r\n  };\r\n\r\n  force.size = function(x) {\r\n    if (!arguments.length) return size;\r\n    size = x;\r\n    return force;\r\n  };\r\n\r\n  force.linkDistance = function(x) {\r\n    if (!arguments.length) return linkDistance;\r\n    linkDistance = d3.functor(x);\r\n    return force;\r\n  };\r\n\r\n  // For backwards-compatibility.\r\n  force.distance = force.linkDistance;\r\n\r\n  force.linkStrength = function(x) {\r\n    if (!arguments.length) return linkStrength;\r\n    linkStrength = d3.functor(x);\r\n    return force;\r\n  };\r\n\r\n  force.friction = function(x) {\r\n    if (!arguments.length) return friction;\r\n    friction = x;\r\n    return force;\r\n  };\r\n\r\n  force.charge = function(x) {\r\n    if (!arguments.length) return charge;\r\n    charge = typeof x === \"function\" ? x : +x;\r\n    return force;\r\n  };\r\n\r\n  force.gravity = function(x) {\r\n    if (!arguments.length) return gravity;\r\n    gravity = x;\r\n    return force;\r\n  };\r\n\r\n  force.theta = function(x) {\r\n    if (!arguments.length) return theta;\r\n    theta = x;\r\n    return force;\r\n  };\r\n\r\n  force.start = function() {\r\n    var i,\r\n        j,\r\n        n = nodes.length,\r\n        m = links.length,\r\n        w = size[0],\r\n        h = size[1],\r\n        neighbors,\r\n        o;\r\n\r\n    for (i = 0; i < n; ++i) {\r\n      (o = nodes[i]).index = i;\r\n      o.weight = 0;\r\n    }\r\n\r\n    distances = [];\r\n    strengths = [];\r\n    for (i = 0; i < m; ++i) {\r\n      o = links[i];\r\n      if (typeof o.source == \"number\") o.source = nodes[o.source];\r\n      if (typeof o.target == \"number\") o.target = nodes[o.target];\r\n      distances[i] = linkDistance.call(this, o, i);\r\n      strengths[i] = linkStrength.call(this, o, i);\r\n      ++o.source.weight;\r\n      ++o.target.weight;\r\n    }\r\n\r\n    for (i = 0; i < n; ++i) {\r\n      o = nodes[i];\r\n      if (isNaN(o.x)) o.x = position(\"x\", w);\r\n      if (isNaN(o.y)) o.y = position(\"y\", h);\r\n      if (isNaN(o.px)) o.px = o.x;\r\n      if (isNaN(o.py)) o.py = o.y;\r\n    }\r\n\r\n    charges = [];\r\n    if (typeof charge === \"function\") {\r\n      for (i = 0; i < n; ++i) {\r\n        charges[i] = +charge.call(this, nodes[i], i);\r\n      }\r\n    } else {\r\n      for (i = 0; i < n; ++i) {\r\n        charges[i] = charge;\r\n      }\r\n    }\r\n\r\n    // initialize node position based on first neighbor\r\n    function position(dimension, size) {\r\n      var neighbors = neighbor(i),\r\n          j = -1,\r\n          m = neighbors.length,\r\n          x;\r\n      while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;\r\n      return Math.random() * size;\r\n    }\r\n\r\n    // initialize neighbors lazily\r\n    function neighbor() {\r\n      if (!neighbors) {\r\n        neighbors = [];\r\n        for (j = 0; j < n; ++j) {\r\n          neighbors[j] = [];\r\n        }\r\n        for (j = 0; j < m; ++j) {\r\n          var o = links[j];\r\n          neighbors[o.source.index].push(o.target);\r\n          neighbors[o.target.index].push(o.source);\r\n        }\r\n      }\r\n      return neighbors[i];\r\n    }\r\n\r\n    return force.resume();\r\n  };\r\n\r\n  force.resume = function() {\r\n    alpha = .1;\r\n    d3.timer(tick);\r\n    return force;\r\n  };\r\n\r\n  force.stop = function() {\r\n    alpha = 0;\r\n    return force;\r\n  };\r\n\r\n  // use `node.call(force.drag)` to make nodes draggable\r\n  force.drag = function() {\r\n    if (!drag) drag = d3.behavior.drag()\r\n        .on(\"dragstart\", dragstart)\r\n        .on(\"drag\", d3_layout_forceDrag)\r\n        .on(\"dragend\", d3_layout_forceDragEnd);\r\n\r\n    this.on(\"mouseover.force\", d3_layout_forceDragOver)\r\n        .on(\"mouseout.force\", d3_layout_forceDragOut)\r\n        .call(drag);\r\n  };\r\n\r\n  function dragstart(d) {\r\n    d3_layout_forceDragOver(d3_layout_forceDragNode = d);\r\n    d3_layout_forceDragForce = force;\r\n  }\r\n\r\n  return force;\r\n};\r\n\r\nvar d3_layout_forceDragForce,\r\n    d3_layout_forceDragNode;\r\n\r\nfunction d3_layout_forceDragOver(d) {\r\n  d.fixed |= 2;\r\n}\r\n\r\nfunction d3_layout_forceDragOut(d) {\r\n  if (d !== d3_layout_forceDragNode) d.fixed &= 1;\r\n}\r\n\r\nfunction d3_layout_forceDragEnd() {\r\n  d3_layout_forceDrag();\r\n  d3_layout_forceDragNode.fixed &= 1;\r\n  d3_layout_forceDragForce = d3_layout_forceDragNode = null;\r\n}\r\n\r\nfunction d3_layout_forceDrag() {\r\n  d3_layout_forceDragNode.px += d3.event.dx;\r\n  d3_layout_forceDragNode.py += d3.event.dy;\r\n  d3_layout_forceDragForce.resume(); // restart annealing\r\n}\r\n\r\nfunction d3_layout_forceAccumulate(quad, alpha, charges) {\r\n  var cx = 0,\r\n      cy = 0;\r\n  quad.charge = 0;\r\n  if (!quad.leaf) {\r\n    var nodes = quad.nodes,\r\n        n = nodes.length,\r\n        i = -1,\r\n        c;\r\n    while (++i < n) {\r\n      c = nodes[i];\r\n      if (c == null) continue;\r\n      d3_layout_forceAccumulate(c, alpha, charges);\r\n      quad.charge += c.charge;\r\n      cx += c.charge * c.cx;\r\n      cy += c.charge * c.cy;\r\n    }\r\n  }\r\n  if (quad.point) {\r\n    // jitter internal nodes that are coincident\r\n    if (!quad.leaf) {\r\n      quad.point.x += Math.random() - .5;\r\n      quad.point.y += Math.random() - .5;\r\n    }\r\n    var k = alpha * charges[quad.point.index];\r\n    quad.charge += quad.pointCharge = k;\r\n    cx += k * quad.point.x;\r\n    cy += k * quad.point.y;\r\n  }\r\n  quad.cx = cx / quad.charge;\r\n  quad.cy = cy / quad.charge;\r\n}\r\n\r\nfunction d3_layout_forceLinkDistance(link) {\r\n  return 20;\r\n}\r\n\r\nfunction d3_layout_forceLinkStrength(link) {\r\n  return 1;\r\n}\r\nd3.layout.partition = function() {\r\n  var hierarchy = d3.layout.hierarchy(),\r\n      size = [1, 1]; // width, height\r\n\r\n  function position(node, x, dx, dy) {\r\n    var children = node.children;\r\n    node.x = x;\r\n    node.y = node.depth * dy;\r\n    node.dx = dx;\r\n    node.dy = dy;\r\n    if (children && (n = children.length)) {\r\n      var i = -1,\r\n          n,\r\n          c,\r\n          d;\r\n      dx = node.value ? dx / node.value : 0;\r\n      while (++i < n) {\r\n        position(c = children[i], x, d = c.value * dx, dy);\r\n        x += d;\r\n      }\r\n    }\r\n  }\r\n\r\n  function depth(node) {\r\n    var children = node.children,\r\n        d = 0;\r\n    if (children && (n = children.length)) {\r\n      var i = -1,\r\n          n;\r\n      while (++i < n) d = Math.max(d, depth(children[i]));\r\n    }\r\n    return 1 + d;\r\n  }\r\n\r\n  function partition(d, i) {\r\n    var nodes = hierarchy.call(this, d, i);\r\n    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\r\n    return nodes;\r\n  }\r\n\r\n  partition.size = function(x) {\r\n    if (!arguments.length) return size;\r\n    size = x;\r\n    return partition;\r\n  };\r\n\r\n  return d3_layout_hierarchyRebind(partition, hierarchy);\r\n};\r\nd3.layout.pie = function() {\r\n  var value = Number,\r\n      sort = null,\r\n      startAngle = 0,\r\n      endAngle = 2 * Math.PI;\r\n\r\n  function pie(data, i) {\r\n\r\n    // Compute the start angle.\r\n    var a = +(typeof startAngle === \"function\"\r\n        ? startAngle.apply(this, arguments)\r\n        : startAngle);\r\n\r\n    // Compute the angular range (end - start).\r\n    var k = (typeof endAngle === \"function\"\r\n        ? endAngle.apply(this, arguments)\r\n        : endAngle) - startAngle;\r\n\r\n    // Optionally sort the data.\r\n    var index = d3.range(data.length);\r\n    if (sort != null) index.sort(function(i, j) {\r\n      return sort(data[i], data[j]);\r\n    });\r\n\r\n    // Compute the numeric values for each data element.\r\n    var values = data.map(value);\r\n\r\n    // Convert k into a scale factor from value to angle, using the sum.\r\n    k /= values.reduce(function(p, d) { return p + d; }, 0);\r\n\r\n    // Compute the arcs!\r\n    var arcs = index.map(function(i) {\r\n      return {\r\n        data: data[i],\r\n        value: d = values[i],\r\n        startAngle: a,\r\n        endAngle: a += d * k\r\n      };\r\n    });\r\n\r\n    // Return the arcs in the original data's order.\r\n    return data.map(function(d, i) {\r\n      return arcs[index[i]];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specifies the value function *x*, which returns a nonnegative numeric value\r\n   * for each datum. The default value function is `Number`. The value function\r\n   * is passed two arguments: the current datum and the current index.\r\n   */\r\n  pie.value = function(x) {\r\n    if (!arguments.length) return value;\r\n    value = x;\r\n    return pie;\r\n  };\r\n\r\n  /**\r\n   * Specifies a sort comparison operator *x*. The comparator is passed two data\r\n   * elements from the data array, a and b; it returns a negative value if a is\r\n   * less than b, a positive value if a is greater than b, and zero if a equals\r\n   * b.\r\n   */\r\n  pie.sort = function(x) {\r\n    if (!arguments.length) return sort;\r\n    sort = x;\r\n    return pie;\r\n  };\r\n\r\n  /**\r\n   * Specifies the overall start angle of the pie chart. Defaults to 0. The\r\n   * start angle can be specified either as a constant or as a function; in the\r\n   * case of a function, it is evaluated once per array (as opposed to per\r\n   * element).\r\n   */\r\n  pie.startAngle = function(x) {\r\n    if (!arguments.length) return startAngle;\r\n    startAngle = x;\r\n    return pie;\r\n  };\r\n\r\n  /**\r\n   * Specifies the overall end angle of the pie chart. Defaults to 2Ï€. The\r\n   * end angle can be specified either as a constant or as a function; in the\r\n   * case of a function, it is evaluated once per array (as opposed to per\r\n   * element).\r\n   */\r\n  pie.endAngle = function(x) {\r\n    if (!arguments.length) return endAngle;\r\n    endAngle = x;\r\n    return pie;\r\n  };\r\n\r\n  return pie;\r\n};\r\n// data is two-dimensional array of x,y; we populate y0\r\nd3.layout.stack = function() {\r\n  var values = Object,\r\n      order = d3_layout_stackOrders[\"default\"],\r\n      offset = d3_layout_stackOffsets[\"zero\"],\r\n      out = d3_layout_stackOut,\r\n      x = d3_layout_stackX,\r\n      y = d3_layout_stackY;\r\n\r\n  function stack(data, index) {\r\n\r\n    // Convert series to canonical two-dimensional representation.\r\n    var series = data.map(function(d, i) {\r\n      return values.call(stack, d, i);\r\n    });\r\n\r\n    // Convert each series to canonical [[x,y]] representation.\r\n    var points = series.map(function(d, i) {\r\n      return d.map(function(v, i) {\r\n        return [x.call(stack, v, i), y.call(stack, v, i)];\r\n      });\r\n    });\r\n\r\n    // Compute the order of series, and permute them.\r\n    var orders = order.call(stack, points, index);\r\n    series = d3.permute(series, orders);\r\n    points = d3.permute(points, orders);\r\n\r\n    // Compute the baselineâ€¦\r\n    var offsets = offset.call(stack, points, index);\r\n\r\n    // And propagate it to other series.\r\n    var n = series.length,\r\n        m = series[0].length,\r\n        i,\r\n        j,\r\n        o;\r\n    for (j = 0; j < m; ++j) {\r\n      out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\r\n      for (i = 1; i < n; ++i) {\r\n        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  stack.values = function(x) {\r\n    if (!arguments.length) return values;\r\n    values = x;\r\n    return stack;\r\n  };\r\n\r\n  stack.order = function(x) {\r\n    if (!arguments.length) return order;\r\n    order = typeof x === \"function\" ? x : d3_layout_stackOrders[x];\r\n    return stack;\r\n  };\r\n\r\n  stack.offset = function(x) {\r\n    if (!arguments.length) return offset;\r\n    offset = typeof x === \"function\" ? x : d3_layout_stackOffsets[x];\r\n    return stack;\r\n  };\r\n\r\n  stack.x = function(z) {\r\n    if (!arguments.length) return x;\r\n    x = z;\r\n    return stack;\r\n  };\r\n\r\n  stack.y = function(z) {\r\n    if (!arguments.length) return y;\r\n    y = z;\r\n    return stack;\r\n  };\r\n\r\n  stack.out = function(z) {\r\n    if (!arguments.length) return out;\r\n    out = z;\r\n    return stack;\r\n  };\r\n\r\n  return stack;\r\n}\r\n\r\nfunction d3_layout_stackX(d) {\r\n  return d.x;\r\n}\r\n\r\nfunction d3_layout_stackY(d) {\r\n  return d.y;\r\n}\r\n\r\nfunction d3_layout_stackOut(d, y0, y) {\r\n  d.y0 = y0;\r\n  d.y = y;\r\n}\r\n\r\nvar d3_layout_stackOrders = {\r\n\r\n  \"inside-out\": function(data) {\r\n    var n = data.length,\r\n        i,\r\n        j,\r\n        max = data.map(d3_layout_stackMaxIndex),\r\n        sums = data.map(d3_layout_stackReduceSum),\r\n        index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }),\r\n        top = 0,\r\n        bottom = 0,\r\n        tops = [],\r\n        bottoms = [];\r\n    for (i = 0; i < n; ++i) {\r\n      j = index[i];\r\n      if (top < bottom) {\r\n        top += sums[j];\r\n        tops.push(j);\r\n      } else {\r\n        bottom += sums[j];\r\n        bottoms.push(j);\r\n      }\r\n    }\r\n    return bottoms.reverse().concat(tops);\r\n  },\r\n\r\n  \"reverse\": function(data) {\r\n    return d3.range(data.length).reverse();\r\n  },\r\n\r\n  \"default\": function(data) {\r\n    return d3.range(data.length);\r\n  }\r\n\r\n};\r\n\r\nvar d3_layout_stackOffsets = {\r\n\r\n  \"silhouette\": function(data) {\r\n    var n = data.length,\r\n        m = data[0].length,\r\n        sums = [],\r\n        max = 0,\r\n        i,\r\n        j,\r\n        o,\r\n        y0 = [];\r\n    for (j = 0; j < m; ++j) {\r\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\r\n      if (o > max) max = o;\r\n      sums.push(o);\r\n    }\r\n    for (j = 0; j < m; ++j) {\r\n      y0[j] = (max - sums[j]) / 2;\r\n    }\r\n    return y0;\r\n  },\r\n\r\n  \"wiggle\": function(data) {\r\n    var n = data.length,\r\n        x = data[0],\r\n        m = x.length,\r\n        max = 0,\r\n        i,\r\n        j,\r\n        k,\r\n        s1,\r\n        s2,\r\n        s3,\r\n        dx,\r\n        o,\r\n        o0,\r\n        y0 = [];\r\n    y0[0] = o = o0 = 0;\r\n    for (j = 1; j < m; ++j) {\r\n      for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\r\n      for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\r\n        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\r\n          s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\r\n        }\r\n        s2 += s3 * data[i][j][1];\r\n      }\r\n      y0[j] = o -= s1 ? s2 / s1 * dx : 0;\r\n      if (o < o0) o0 = o;\r\n    }\r\n    for (j = 0; j < m; ++j) y0[j] -= o0;\r\n    return y0;\r\n  },\r\n\r\n  \"expand\": function(data) {\r\n    var n = data.length,\r\n        m = data[0].length,\r\n        k = 1 / n,\r\n        i,\r\n        j,\r\n        o,\r\n        y0 = [];\r\n    for (j = 0; j < m; ++j) {\r\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\r\n      if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;\r\n      else for (i = 0; i < n; i++) data[i][j][1] = k;\r\n    }\r\n    for (j = 0; j < m; ++j) y0[j] = 0;\r\n    return y0;\r\n  },\r\n\r\n  \"zero\": function(data) {\r\n    var j = -1,\r\n        m = data[0].length,\r\n        y0 = [];\r\n    while (++j < m) y0[j] = 0;\r\n    return y0;\r\n  }\r\n\r\n};\r\n\r\nfunction d3_layout_stackMaxIndex(array) {\r\n  var i = 1,\r\n      j = 0,\r\n      v = array[0][1],\r\n      k,\r\n      n = array.length;\r\n  for (; i < n; ++i) {\r\n    if ((k = array[i][1]) > v) {\r\n      j = i;\r\n      v = k;\r\n    }\r\n  }\r\n  return j;\r\n}\r\n\r\nfunction d3_layout_stackReduceSum(d) {\r\n  return d.reduce(d3_layout_stackSum, 0);\r\n}\r\n\r\nfunction d3_layout_stackSum(p, d) {\r\n  return p + d[1];\r\n}\r\nd3.layout.histogram = function() {\r\n  var frequency = true,\r\n      valuer = Number,\r\n      ranger = d3_layout_histogramRange,\r\n      binner = d3_layout_histogramBinSturges;\r\n\r\n  function histogram(data, i) {\r\n    var bins = [],\r\n        values = data.map(valuer, this),\r\n        range = ranger.call(this, values, i),\r\n        thresholds = binner.call(this, range, values, i),\r\n        bin,\r\n        i = -1,\r\n        n = values.length,\r\n        m = thresholds.length - 1,\r\n        k = frequency ? 1 : 1 / n,\r\n        x;\r\n\r\n    // Initialize the bins.\r\n    while (++i < m) {\r\n      bin = bins[i] = [];\r\n      bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\r\n      bin.y = 0;\r\n    }\r\n\r\n    // Fill the bins, ignoring values outside the range.\r\n    i = -1; while(++i < n) {\r\n      x = values[i];\r\n      if ((x >= range[0]) && (x <= range[1])) {\r\n        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\r\n        bin.y += k;\r\n        bin.push(data[i]);\r\n      }\r\n    }\r\n\r\n    return bins;\r\n  }\r\n\r\n  // Specifies how to extract a value from the associated data. The default\r\n  // value function is `Number`, which is equivalent to the identity function.\r\n  histogram.value = function(x) {\r\n    if (!arguments.length) return valuer;\r\n    valuer = x;\r\n    return histogram;\r\n  };\r\n\r\n  // Specifies the range of the histogram. Values outside the specified range\r\n  // will be ignored. The argument `x` may be specified either as a two-element\r\n  // array representing the minimum and maximum value of the range, or as a\r\n  // function that returns the range given the array of values and the current\r\n  // index `i`. The default range is the extent (minimum and maximum) of the\r\n  // values.\r\n  histogram.range = function(x) {\r\n    if (!arguments.length) return ranger;\r\n    ranger = d3.functor(x);\r\n    return histogram;\r\n  };\r\n\r\n  // Specifies how to bin values in the histogram. The argument `x` may be\r\n  // specified as a number, in which case the range of values will be split\r\n  // uniformly into the given number of bins. Or, `x` may be an array of\r\n  // threshold values, defining the bins; the specified array must contain the\r\n  // rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x`\r\n  // may be a function which is evaluated, being passed the range, the array of\r\n  // values, and the current index `i`, returning an array of thresholds. The\r\n  // default bin function will divide the values into uniform bins using\r\n  // Sturges' formula.\r\n  histogram.bins = function(x) {\r\n    if (!arguments.length) return binner;\r\n    binner = typeof x === \"number\"\r\n        ? function(range) { return d3_layout_histogramBinFixed(range, x); }\r\n        : d3.functor(x);\r\n    return histogram;\r\n  };\r\n\r\n  // Specifies whether the histogram's `y` value is a count (frequency) or a\r\n  // probability (density). The default value is true.\r\n  histogram.frequency = function(x) {\r\n    if (!arguments.length) return frequency;\r\n    frequency = !!x;\r\n    return histogram;\r\n  };\r\n\r\n  return histogram;\r\n};\r\n\r\nfunction d3_layout_histogramBinSturges(range, values) {\r\n  return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\r\n}\r\n\r\nfunction d3_layout_histogramBinFixed(range, n) {\r\n  var x = -1,\r\n      b = +range[0],\r\n      m = (range[1] - b) / n,\r\n      f = [];\r\n  while (++x <= n) f[x] = m * x + b;\r\n  return f;\r\n}\r\n\r\nfunction d3_layout_histogramRange(values) {\r\n  return [d3.min(values), d3.max(values)];\r\n}\r\nd3.layout.hierarchy = function() {\r\n  var sort = d3_layout_hierarchySort,\r\n      children = d3_layout_hierarchyChildren,\r\n      value = d3_layout_hierarchyValue;\r\n\r\n  // Recursively compute the node depth and value.\r\n  // Also converts the data representation into a standard hierarchy structure.\r\n  function recurse(data, depth, nodes) {\r\n    var childs = children.call(hierarchy, data, depth),\r\n        node = d3_layout_hierarchyInline ? data : {data: data};\r\n    node.depth = depth;\r\n    nodes.push(node);\r\n    if (childs && (n = childs.length)) {\r\n      var i = -1,\r\n          n,\r\n          c = node.children = [],\r\n          v = 0,\r\n          j = depth + 1;\r\n      while (++i < n) {\r\n        d = recurse(childs[i], j, nodes);\r\n        d.parent = node;\r\n        c.push(d);\r\n        v += d.value;\r\n      }\r\n      if (sort) c.sort(sort);\r\n      if (value) node.value = v;\r\n    } else if (value) {\r\n      node.value = +value.call(hierarchy, data, depth) || 0;\r\n    }\r\n    return node;\r\n  }\r\n\r\n  // Recursively re-evaluates the node value.\r\n  function revalue(node, depth) {\r\n    var children = node.children,\r\n        v = 0;\r\n    if (children && (n = children.length)) {\r\n      var i = -1,\r\n          n,\r\n          j = depth + 1;\r\n      while (++i < n) v += revalue(children[i], j);\r\n    } else if (value) {\r\n      v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;\r\n    }\r\n    if (value) node.value = v;\r\n    return v;\r\n  }\r\n\r\n  function hierarchy(d) {\r\n    var nodes = [];\r\n    recurse(d, 0, nodes);\r\n    return nodes;\r\n  }\r\n\r\n  hierarchy.sort = function(x) {\r\n    if (!arguments.length) return sort;\r\n    sort = x;\r\n    return hierarchy;\r\n  };\r\n\r\n  hierarchy.children = function(x) {\r\n    if (!arguments.length) return children;\r\n    children = x;\r\n    return hierarchy;\r\n  };\r\n\r\n  hierarchy.value = function(x) {\r\n    if (!arguments.length) return value;\r\n    value = x;\r\n    return hierarchy;\r\n  };\r\n\r\n  // Re-evaluates the `value` property for the specified hierarchy.\r\n  hierarchy.revalue = function(root) {\r\n    revalue(root, 0);\r\n    return root;\r\n  };\r\n\r\n  return hierarchy;\r\n};\r\n\r\n// A method assignment helper for hierarchy subclasses.\r\nfunction d3_layout_hierarchyRebind(object, hierarchy) {\r\n  object.sort = d3.rebind(object, hierarchy.sort);\r\n  object.children = d3.rebind(object, hierarchy.children);\r\n  object.links = d3_layout_hierarchyLinks;\r\n  object.value = d3.rebind(object, hierarchy.value);\r\n\r\n  // If the new API is used, enabling inlining.\r\n  object.nodes = function(d) {\r\n    d3_layout_hierarchyInline = true;\r\n    return (object.nodes = object)(d);\r\n  };\r\n\r\n  return object;\r\n}\r\n\r\nfunction d3_layout_hierarchyChildren(d) {\r\n  return d.children;\r\n}\r\n\r\nfunction d3_layout_hierarchyValue(d) {\r\n  return d.value;\r\n}\r\n\r\nfunction d3_layout_hierarchySort(a, b) {\r\n  return b.value - a.value;\r\n}\r\n\r\n// Returns an array source+target objects for the specified nodes.\r\nfunction d3_layout_hierarchyLinks(nodes) {\r\n  return d3.merge(nodes.map(function(parent) {\r\n    return (parent.children || []).map(function(child) {\r\n      return {source: parent, target: child};\r\n    });\r\n  }));\r\n}\r\n\r\n// For backwards-compatibility, don't enable inlining by default.\r\nvar d3_layout_hierarchyInline = false;\r\nd3.layout.pack = function() {\r\n  var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),\r\n      size = [1, 1];\r\n\r\n  function pack(d, i) {\r\n    var nodes = hierarchy.call(this, d, i),\r\n        root = nodes[0];\r\n\r\n    // Recursively compute the layout.\r\n    root.x = 0;\r\n    root.y = 0;\r\n    d3_layout_packTree(root);\r\n\r\n    // Scale the layout to fit the requested size.\r\n    var w = size[0],\r\n        h = size[1],\r\n        k = 1 / Math.max(2 * root.r / w, 2 * root.r / h);\r\n    d3_layout_packTransform(root, w / 2, h / 2, k);\r\n\r\n    return nodes;\r\n  }\r\n\r\n  pack.size = function(x) {\r\n    if (!arguments.length) return size;\r\n    size = x;\r\n    return pack;\r\n  };\r\n\r\n  return d3_layout_hierarchyRebind(pack, hierarchy);\r\n};\r\n\r\nfunction d3_layout_packSort(a, b) {\r\n  return a.value - b.value;\r\n}\r\n\r\nfunction d3_layout_packInsert(a, b) {\r\n  var c = a._pack_next;\r\n  a._pack_next = b;\r\n  b._pack_prev = a;\r\n  b._pack_next = c;\r\n  c._pack_prev = b;\r\n}\r\n\r\nfunction d3_layout_packSplice(a, b) {\r\n  a._pack_next = b;\r\n  b._pack_prev = a;\r\n}\r\n\r\nfunction d3_layout_packIntersects(a, b) {\r\n  var dx = b.x - a.x,\r\n      dy = b.y - a.y,\r\n      dr = a.r + b.r;\r\n  return (dr * dr - dx * dx - dy * dy) > .001; // within epsilon\r\n}\r\n\r\nfunction d3_layout_packCircle(nodes) {\r\n  var xMin = Infinity,\r\n      xMax = -Infinity,\r\n      yMin = Infinity,\r\n      yMax = -Infinity,\r\n      n = nodes.length,\r\n      a, b, c, j, k;\r\n\r\n  function bound(node) {\r\n    xMin = Math.min(node.x - node.r, xMin);\r\n    xMax = Math.max(node.x + node.r, xMax);\r\n    yMin = Math.min(node.y - node.r, yMin);\r\n    yMax = Math.max(node.y + node.r, yMax);\r\n  }\r\n\r\n  // Create node links.\r\n  nodes.forEach(d3_layout_packLink);\r\n\r\n  // Create first node.\r\n  a = nodes[0];\r\n  a.x = -a.r;\r\n  a.y = 0;\r\n  bound(a);\r\n\r\n  // Create second node.\r\n  if (n > 1) {\r\n    b = nodes[1];\r\n    b.x = b.r;\r\n    b.y = 0;\r\n    bound(b);\r\n\r\n    // Create third node and build chain.\r\n    if (n > 2) {\r\n      c = nodes[2];\r\n      d3_layout_packPlace(a, b, c);\r\n      bound(c);\r\n      d3_layout_packInsert(a, c);\r\n      a._pack_prev = c;\r\n      d3_layout_packInsert(c, b);\r\n      b = a._pack_next;\r\n\r\n      // Now iterate through the rest.\r\n      for (var i = 3; i < n; i++) {\r\n        d3_layout_packPlace(a, b, c = nodes[i]);\r\n\r\n        // Search for the closest intersection.\r\n        var isect = 0, s1 = 1, s2 = 1;\r\n        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\r\n          if (d3_layout_packIntersects(j, c)) {\r\n            isect = 1;\r\n            break;\r\n          }\r\n        }\r\n        if (isect == 1) {\r\n          for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\r\n            if (d3_layout_packIntersects(k, c)) {\r\n              if (s2 < s1) {\r\n                isect = -1;\r\n                j = k;\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Update node chain.\r\n        if (isect == 0) {\r\n          d3_layout_packInsert(a, c);\r\n          b = c;\r\n          bound(c);\r\n        } else if (isect > 0) {\r\n          d3_layout_packSplice(a, j);\r\n          b = j;\r\n          i--;\r\n        } else { // isect < 0\r\n          d3_layout_packSplice(j, b);\r\n          a = j;\r\n          i--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Re-center the circles and return the encompassing radius.\r\n  var cx = (xMin + xMax) / 2,\r\n      cy = (yMin + yMax) / 2,\r\n      cr = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    var node = nodes[i];\r\n    node.x -= cx;\r\n    node.y -= cy;\r\n    cr = Math.max(cr, node.r + Math.sqrt(node.x * node.x + node.y * node.y));\r\n  }\r\n\r\n  // Remove node links.\r\n  nodes.forEach(d3_layout_packUnlink);\r\n\r\n  return cr;\r\n}\r\n\r\nfunction d3_layout_packLink(node) {\r\n  node._pack_next = node._pack_prev = node;\r\n}\r\n\r\nfunction d3_layout_packUnlink(node) {\r\n  delete node._pack_next;\r\n  delete node._pack_prev;\r\n}\r\n\r\nfunction d3_layout_packTree(node) {\r\n  var children = node.children;\r\n  if (children && children.length) {\r\n    children.forEach(d3_layout_packTree);\r\n    node.r = d3_layout_packCircle(children);\r\n  } else {\r\n    node.r = Math.sqrt(node.value);\r\n  }\r\n}\r\n\r\nfunction d3_layout_packTransform(node, x, y, k) {\r\n  var children = node.children;\r\n  node.x = (x += k * node.x);\r\n  node.y = (y += k * node.y);\r\n  node.r *= k;\r\n  if (children) {\r\n    var i = -1, n = children.length;\r\n    while (++i < n) d3_layout_packTransform(children[i], x, y, k);\r\n  }\r\n}\r\n\r\nfunction d3_layout_packPlace(a, b, c) {\r\n  var db = a.r + c.r,\r\n      dx = b.x - a.x,\r\n      dy = b.y - a.y;\r\n  if (db && (dx || dy)) {\r\n    var da = b.r + c.r,\r\n        dc = Math.sqrt(dx * dx + dy * dy),\r\n        cos = Math.max(-1, Math.min(1, (db * db + dc * dc - da * da) / (2 * db * dc))),\r\n        theta = Math.acos(cos),\r\n        x = cos * (db /= dc),\r\n        y = Math.sin(theta) * db;\r\n    c.x = a.x + x * dx + y * dy;\r\n    c.y = a.y + x * dy - y * dx;\r\n  } else {\r\n    c.x = a.x + db;\r\n    c.y = a.y;\r\n  }\r\n}\r\n// Implements a hierarchical layout using the cluster (or dendogram) algorithm.\r\nd3.layout.cluster = function() {\r\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\r\n      separation = d3_layout_treeSeparation,\r\n      size = [1, 1]; // width, height\r\n\r\n  function cluster(d, i) {\r\n    var nodes = hierarchy.call(this, d, i),\r\n        root = nodes[0],\r\n        previousNode,\r\n        x = 0,\r\n        kx,\r\n        ky;\r\n\r\n    // First walk, computing the initial x & y values.\r\n    d3_layout_treeVisitAfter(root, function(node) {\r\n      var children = node.children;\r\n      if (children && children.length) {\r\n        node.x = d3_layout_clusterX(children);\r\n        node.y = d3_layout_clusterY(children);\r\n      } else {\r\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\r\n        node.y = 0;\r\n        previousNode = node;\r\n      }\r\n    });\r\n\r\n    // Compute the left-most, right-most, and depth-most nodes for extents.\r\n    var left = d3_layout_clusterLeft(root),\r\n        right = d3_layout_clusterRight(root),\r\n        x0 = left.x - separation(left, right) / 2,\r\n        x1 = right.x + separation(right, left) / 2;\r\n\r\n    // Second walk, normalizing x & y to the desired size.\r\n    d3_layout_treeVisitAfter(root, function(node) {\r\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\r\n      node.y = (1 - node.y / root.y) * size[1];\r\n    });\r\n\r\n    return nodes;\r\n  }\r\n\r\n  cluster.separation = function(x) {\r\n    if (!arguments.length) return separation;\r\n    separation = x;\r\n    return cluster;\r\n  };\r\n\r\n  cluster.size = function(x) {\r\n    if (!arguments.length) return size;\r\n    size = x;\r\n    return cluster;\r\n  };\r\n\r\n  return d3_layout_hierarchyRebind(cluster, hierarchy);\r\n};\r\n\r\nfunction d3_layout_clusterY(children) {\r\n  return 1 + d3.max(children, function(child) {\r\n    return child.y;\r\n  });\r\n}\r\n\r\nfunction d3_layout_clusterX(children) {\r\n  return children.reduce(function(x, child) {\r\n    return x + child.x;\r\n  }, 0) / children.length;\r\n}\r\n\r\nfunction d3_layout_clusterLeft(node) {\r\n  var children = node.children;\r\n  return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\r\n}\r\n\r\nfunction d3_layout_clusterRight(node) {\r\n  var children = node.children, n;\r\n  return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\r\n}\r\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\r\nd3.layout.tree = function() {\r\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\r\n      separation = d3_layout_treeSeparation,\r\n      size = [1, 1]; // width, height\r\n\r\n  function tree(d, i) {\r\n    var nodes = hierarchy.call(this, d, i),\r\n        root = nodes[0];\r\n\r\n    function firstWalk(node, previousSibling) {\r\n      var children = node.children,\r\n          layout = node._tree;\r\n      if (children && (n = children.length)) {\r\n        var n,\r\n            firstChild = children[0],\r\n            previousChild,\r\n            ancestor = firstChild,\r\n            child,\r\n            i = -1;\r\n        while (++i < n) {\r\n          child = children[i];\r\n          firstWalk(child, previousChild);\r\n          ancestor = apportion(child, previousChild, ancestor);\r\n          previousChild = child;\r\n        }\r\n        d3_layout_treeShift(node);\r\n        var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);\r\n        if (previousSibling) {\r\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\r\n          layout.mod = layout.prelim - midpoint;\r\n        } else {\r\n          layout.prelim = midpoint;\r\n        }\r\n      } else {\r\n        if (previousSibling) {\r\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\r\n        }\r\n      }\r\n    }\r\n\r\n    function secondWalk(node, x) {\r\n      node.x = node._tree.prelim + x;\r\n      var children = node.children;\r\n      if (children && (n = children.length)) {\r\n        var i = -1,\r\n            n;\r\n        x += node._tree.mod;\r\n        while (++i < n) {\r\n          secondWalk(children[i], x);\r\n        }\r\n      }\r\n    }\r\n\r\n    function apportion(node, previousSibling, ancestor) {\r\n      if (previousSibling) {\r\n        var vip = node,\r\n            vop = node,\r\n            vim = previousSibling,\r\n            vom = node.parent.children[0],\r\n            sip = vip._tree.mod,\r\n            sop = vop._tree.mod,\r\n            sim = vim._tree.mod,\r\n            som = vom._tree.mod,\r\n            shift;\r\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\r\n          vom = d3_layout_treeLeft(vom);\r\n          vop = d3_layout_treeRight(vop);\r\n          vop._tree.ancestor = node;\r\n          shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);\r\n          if (shift > 0) {\r\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);\r\n            sip += shift;\r\n            sop += shift;\r\n          }\r\n          sim += vim._tree.mod;\r\n          sip += vip._tree.mod;\r\n          som += vom._tree.mod;\r\n          sop += vop._tree.mod;\r\n        }\r\n        if (vim && !d3_layout_treeRight(vop)) {\r\n          vop._tree.thread = vim;\r\n          vop._tree.mod += sim - sop;\r\n        }\r\n        if (vip && !d3_layout_treeLeft(vom)) {\r\n          vom._tree.thread = vip;\r\n          vom._tree.mod += sip - som;\r\n          ancestor = node;\r\n        }\r\n      }\r\n      return ancestor;\r\n    }\r\n\r\n    // Initialize temporary layout variables.\r\n    d3_layout_treeVisitAfter(root, function(node, previousSibling) {\r\n      node._tree = {\r\n        ancestor: node,\r\n        prelim: 0,\r\n        mod: 0,\r\n        change: 0,\r\n        shift: 0,\r\n        number: previousSibling ? previousSibling._tree.number + 1 : 0\r\n      };\r\n    });\r\n\r\n    // Compute the layout using Buchheim et al.'s algorithm.\r\n    firstWalk(root);\r\n    secondWalk(root, -root._tree.prelim);\r\n\r\n    // Compute the left-most, right-most, and depth-most nodes for extents.\r\n    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),\r\n        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),\r\n        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),\r\n        x0 = left.x - separation(left, right) / 2,\r\n        x1 = right.x + separation(right, left) / 2,\r\n        y1 = deep.depth || 1;\r\n\r\n    // Clear temporary layout variables; transform x and y.\r\n    d3_layout_treeVisitAfter(root, function(node) {\r\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\r\n      node.y = node.depth / y1 * size[1];\r\n      delete node._tree;\r\n    });\r\n\r\n    return nodes;\r\n  }\r\n\r\n  tree.separation = function(x) {\r\n    if (!arguments.length) return separation;\r\n    separation = x;\r\n    return tree;\r\n  };\r\n\r\n  tree.size = function(x) {\r\n    if (!arguments.length) return size;\r\n    size = x;\r\n    return tree;\r\n  };\r\n\r\n  return d3_layout_hierarchyRebind(tree, hierarchy);\r\n};\r\n\r\nfunction d3_layout_treeSeparation(a, b) {\r\n  return a.parent == b.parent ? 1 : 2;\r\n}\r\n\r\n// function d3_layout_treeSeparationRadial(a, b) {\r\n//   return (a.parent == b.parent ? 1 : 2) / a.depth;\r\n// }\r\n\r\nfunction d3_layout_treeLeft(node) {\r\n  var children = node.children;\r\n  return children && children.length ? children[0] : node._tree.thread;\r\n}\r\n\r\nfunction d3_layout_treeRight(node) {\r\n  var children = node.children,\r\n      n;\r\n  return children && (n = children.length) ? children[n - 1] : node._tree.thread;\r\n}\r\n\r\nfunction d3_layout_treeSearch(node, compare) {\r\n  var children = node.children;\r\n  if (children && (n = children.length)) {\r\n    var child,\r\n        n,\r\n        i = -1;\r\n    while (++i < n) {\r\n      if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {\r\n        node = child;\r\n      }\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\nfunction d3_layout_treeRightmost(a, b) {\r\n  return a.x - b.x;\r\n}\r\n\r\nfunction d3_layout_treeLeftmost(a, b) {\r\n  return b.x - a.x;\r\n}\r\n\r\nfunction d3_layout_treeDeepest(a, b) {\r\n  return a.depth - b.depth;\r\n}\r\n\r\nfunction d3_layout_treeVisitAfter(node, callback) {\r\n  function visit(node, previousSibling) {\r\n    var children = node.children;\r\n    if (children && (n = children.length)) {\r\n      var child,\r\n          previousChild = null,\r\n          i = -1,\r\n          n;\r\n      while (++i < n) {\r\n        child = children[i];\r\n        visit(child, previousChild);\r\n        previousChild = child;\r\n      }\r\n    }\r\n    callback(node, previousSibling);\r\n  }\r\n  visit(node, null);\r\n}\r\n\r\nfunction d3_layout_treeShift(node) {\r\n  var shift = 0,\r\n      change = 0,\r\n      children = node.children,\r\n      i = children.length,\r\n      child;\r\n  while (--i >= 0) {\r\n    child = children[i]._tree;\r\n    child.prelim += shift;\r\n    child.mod += shift;\r\n    shift += child.shift + (change += child.change);\r\n  }\r\n}\r\n\r\nfunction d3_layout_treeMove(ancestor, node, shift) {\r\n  ancestor = ancestor._tree;\r\n  node = node._tree;\r\n  var change = shift / (node.number - ancestor.number);\r\n  ancestor.change += change;\r\n  node.change -= change;\r\n  node.shift += shift;\r\n  node.prelim += shift;\r\n  node.mod += shift;\r\n}\r\n\r\nfunction d3_layout_treeAncestor(vim, node, ancestor) {\r\n  return vim._tree.ancestor.parent == node.parent\r\n      ? vim._tree.ancestor\r\n      : ancestor;\r\n}\r\n// Squarified Treemaps by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\r\n// Modified to support a target aspect ratio by Jeff Heer\r\nd3.layout.treemap = function() {\r\n  var hierarchy = d3.layout.hierarchy(),\r\n      round = Math.round,\r\n      size = [1, 1], // width, height\r\n      padding = null,\r\n      pad = d3_layout_treemapPadNull,\r\n      sticky = false,\r\n      stickies,\r\n      ratio = 0.5 * (1 + Math.sqrt(5)); // golden ratio\r\n\r\n  // Compute the area for each child based on value & scale.\r\n  function scale(children, k) {\r\n    var i = -1,\r\n        n = children.length,\r\n        child,\r\n        area;\r\n    while (++i < n) {\r\n      area = (child = children[i]).value * (k < 0 ? 0 : k);\r\n      child.area = isNaN(area) || area <= 0 ? 0 : area;\r\n    }\r\n  }\r\n\r\n  // Recursively arranges the specified node's children into squarified rows.\r\n  function squarify(node) {\r\n    var children = node.children;\r\n    if (children && children.length) {\r\n      var rect = pad(node),\r\n          row = [],\r\n          remaining = children.slice(), // copy-on-write\r\n          child,\r\n          best = Infinity, // the best row score so far\r\n          score, // the current row score\r\n          u = Math.min(rect.dx, rect.dy), // initial orientation\r\n          n;\r\n      scale(remaining, rect.dx * rect.dy / node.value);\r\n      row.area = 0;\r\n      while ((n = remaining.length) > 0) {\r\n        row.push(child = remaining[n - 1]);\r\n        row.area += child.area;\r\n        if ((score = worst(row, u)) <= best) { // continue with this orientation\r\n          remaining.pop();\r\n          best = score;\r\n        } else { // abort, and try a different orientation\r\n          row.area -= row.pop().area;\r\n          position(row, u, rect, false);\r\n          u = Math.min(rect.dx, rect.dy);\r\n          row.length = row.area = 0;\r\n          best = Infinity;\r\n        }\r\n      }\r\n      if (row.length) {\r\n        position(row, u, rect, true);\r\n        row.length = row.area = 0;\r\n      }\r\n      children.forEach(squarify);\r\n    }\r\n  }\r\n\r\n  // Recursively resizes the specified node's children into existing rows.\r\n  // Preserves the existing layout!\r\n  function stickify(node) {\r\n    var children = node.children;\r\n    if (children && children.length) {\r\n      var rect = pad(node),\r\n          remaining = children.slice(), // copy-on-write\r\n          child,\r\n          row = [];\r\n      scale(remaining, rect.dx * rect.dy / node.value);\r\n      row.area = 0;\r\n      while (child = remaining.pop()) {\r\n        row.push(child);\r\n        row.area += child.area;\r\n        if (child.z != null) {\r\n          position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\r\n          row.length = row.area = 0;\r\n        }\r\n      }\r\n      children.forEach(stickify);\r\n    }\r\n  }\r\n\r\n  // Computes the score for the specified row, as the worst aspect ratio.\r\n  function worst(row, u) {\r\n    var s = row.area,\r\n        r,\r\n        rmax = 0,\r\n        rmin = Infinity,\r\n        i = -1,\r\n        n = row.length;\r\n    while (++i < n) {\r\n      if (!(r = row[i].area)) continue;\r\n      if (r < rmin) rmin = r;\r\n      if (r > rmax) rmax = r;\r\n    }\r\n    s *= s;\r\n    u *= u;\r\n    return s\r\n        ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))\r\n        : Infinity;\r\n  }\r\n\r\n  // Positions the specified row of nodes. Modifies `rect`.\r\n  function position(row, u, rect, flush) {\r\n    var i = -1,\r\n        n = row.length,\r\n        x = rect.x,\r\n        y = rect.y,\r\n        v = u ? round(row.area / u) : 0,\r\n        o;\r\n    if (u == rect.dx) { // horizontal subdivision\r\n      if (flush || v > rect.dy) v = v ? rect.dy : 0; // over+underflow\r\n      while (++i < n) {\r\n        o = row[i];\r\n        o.x = x;\r\n        o.y = y;\r\n        o.dy = v;\r\n        x += o.dx = v ? round(o.area / v) : 0;\r\n      }\r\n      o.z = true;\r\n      o.dx += rect.x + rect.dx - x; // rounding error\r\n      rect.y += v;\r\n      rect.dy -= v;\r\n    } else { // vertical subdivision\r\n      if (flush || v > rect.dx) v = v ? rect.dx : 0; // over+underflow\r\n      while (++i < n) {\r\n        o = row[i];\r\n        o.x = x;\r\n        o.y = y;\r\n        o.dx = v;\r\n        y += o.dy = v ? round(o.area / v) : 0;\r\n      }\r\n      o.z = false;\r\n      o.dy += rect.y + rect.dy - y; // rounding error\r\n      rect.x += v;\r\n      rect.dx -= v;\r\n    }\r\n  }\r\n\r\n  function treemap(d) {\r\n    var nodes = stickies || hierarchy(d),\r\n        root = nodes[0];\r\n    root.x = 0;\r\n    root.y = 0;\r\n    root.dx = size[0];\r\n    root.dy = size[1];\r\n    if (stickies) hierarchy.revalue(root);\r\n    scale([root], root.dx * root.dy / root.value);\r\n    (stickies ? stickify : squarify)(root);\r\n    if (sticky) stickies = nodes;\r\n    return nodes;\r\n  }\r\n\r\n  treemap.size = function(x) {\r\n    if (!arguments.length) return size;\r\n    size = x;\r\n    return treemap;\r\n  };\r\n\r\n  treemap.padding = function(x) {\r\n    if (!arguments.length) return padding;\r\n\r\n    function padFunction(node) {\r\n      var p = x.call(treemap, node, node.depth);\r\n      return p == null\r\n          ? d3_layout_treemapPadNull(node)\r\n          : d3_layout_treemapPad(node, typeof p === \"number\" ? [p, p, p, p] : p);\r\n    }\r\n\r\n    function padConstant(node) {\r\n      return d3_layout_treemapPad(node, x);\r\n    }\r\n\r\n    var type;\r\n    pad = (padding = x) == null ? d3_layout_treemapPadNull\r\n        : (type = typeof x) === \"function\" ? padFunction\r\n        : type === \"number\" ? (x = [x, x, x, x], padConstant)\r\n        : padConstant;\r\n    return treemap;\r\n  };\r\n\r\n  treemap.round = function(x) {\r\n    if (!arguments.length) return round != Number;\r\n    round = x ? Math.round : Number;\r\n    return treemap;\r\n  };\r\n\r\n  treemap.sticky = function(x) {\r\n    if (!arguments.length) return sticky;\r\n    sticky = x;\r\n    stickies = null;\r\n    return treemap;\r\n  };\r\n\r\n  treemap.ratio = function(x) {\r\n    if (!arguments.length) return ratio;\r\n    ratio = x;\r\n    return treemap;\r\n  };\r\n\r\n  return d3_layout_hierarchyRebind(treemap, hierarchy);\r\n};\r\n\r\nfunction d3_layout_treemapPadNull(node) {\r\n  return {x: node.x, y: node.y, dx: node.dx, dy: node.dy};\r\n}\r\n\r\nfunction d3_layout_treemapPad(node, padding) {\r\n  var x = node.x + padding[3],\r\n      y = node.y + padding[0],\r\n      dx = node.dx - padding[1] - padding[3],\r\n      dy = node.dy - padding[0] - padding[2];\r\n  if (dx < 0) { x += dx / 2; dx = 0; }\r\n  if (dy < 0) { y += dy / 2; dy = 0; }\r\n  return {x: x, y: y, dx: dx, dy: dy};\r\n}\r\n})();"]],"start1":0,"start2":0,"length1":4906,"length2":50034}]],"length":50034,"saved":false}
